{
    "Feature Component": {
        "prefix": "_FEATURE",
        "body": [
            "import type { FC } from 'react'",
            "",
            "export type ${TM_FILENAME/(^[^.]+).*?([a-zA-Z0-9]*)$/${1:/pascalcase}/}Props = {",
            "\tviews: {",
            "\t\t",
            "\t}",
            "}",
            "",
            "export const ${TM_FILENAME/(^[^.]+).*?([a-zA-Z0-9]*)$/${1:/pascalcase}/}: FC<${TM_FILENAME/(^[^.]+).*?([a-zA-Z0-9]*)$/${1:/pascalcase}/}Props> = ({",
            "\tviews",
            "}) => {",
            "\tconst { } = views",
            "",
            "\treturn undefined",
            "}"
        ],
    },
    "Widget Component": {
        "prefix": "_WIDGET",
        "body": [
            "import type { FC } from 'react'",
            "",
            "export type ${TM_FILENAME/(^[^.]+).*?([a-zA-Z0-9]*)$/${1:/pascalcase}/}WidgetProps = {}",
            "",
            "export const ${TM_FILENAME/(^[^.]+).*?([a-zA-Z0-9]*)$/${1:/pascalcase}/}Widget: FC<${TM_FILENAME/(^[^.]+).*?([a-zA-Z0-9]*)$/${1:/pascalcase}/}WidgetProps> = () => {",
            "\treturn undefined",
            "}"
        ],
    },

    "Store contract": {
		"prefix": "_STORE-CONTRACT",
		"body": [
			"import z from 'zod'",
			"import { ZodCRUDStore, ZodStoreSchemas } from '@/backend/utils/store/store.utils.zod'",
			"",
			"export const ${TM_FILENAME/(^[^.]+).*?([a-zA-Z0-9]*)$/${1:/camelcase}/}StoreSchemas = {",
			"\tmodels: {",
			"\t\tlist: z.object({ $1 }),",
			"\t\tdetails: z.object({ $2 }),",
			"\t},",
			"",
			"\tsearchPayload: {",
			"\t\tlist: z.object({ $3 }),",
			"\t\tspecific: z.object({ $4 }),",
			"\t},",
			"",
			"\tactionsPayload: {",
			"\t\tcreate: z.object({ $5 }),",
			"\t\tupdate: z.object({ $6 }),",
			"\t},",
			"} satisfies ZodStoreSchemas",
			"",
			"export type ${TM_FILENAME/(^[^.]+).*?([a-zA-Z0-9]*)$/${1:/pascalcase}/}Store = ZodCRUDStore<typeof ${TM_FILENAME/(^[^.]+).*?([a-zA-Z0-9]*)$/${1:/camelcase}/}StoreSchemas>"
		]
	},

    "Prisma store implementation": {
		"prefix": "_STORE-PRISMA",
		"body": [
			"import { prismaClient as prisma } from '@/backend/infrastructure'",
			"import { injectable } from 'inversify'",
			"import type { Prisma } from '@prisma/client'",
			"import type { StoreTypes } from '@/backend/utils/store/store.utils.shared-models'",
			"import type { ${TM_FILENAME/(^[^.]+).*?([a-zA-Z0-9]*)$/${1:/pascalcase}/}Store } from './${TM_FILENAME_BASE/\\..*$//}.store'",
			"",
			"type Types = StoreTypes<${TM_FILENAME/(^[^.]+).*?([a-zA-Z0-9]*)$/${1:/pascalcase}/}Store>",
			"",
			"const mappers = {",
			"\ttoFindOnePayload: (source: Types['findOnePayload']): Prisma.${TM_FILENAME/(^[^.]+).*?([a-zA-Z0-9]*)$/${1:/pascalcase}/}WhereUniqueInput => {",
			"\t\treturn {",
			"\t\t\t",
			"\t\t};",
			"\t},",
			"\ttoFindListPayload: (source: Types['findListPayload']): Prisma.${TM_FILENAME/(^[^.]+).*?([a-zA-Z0-9]*)$/${1:/pascalcase}/}WhereInput => {",
			"\t\treturn {",
			"\t\t\t",
			"\t\t};",
			"\t},",
			"\ttoListModel: (source: Prisma.${TM_FILENAME/(^[^.]+).*?([a-zA-Z0-9]*)$/${1:/pascalcase}/}GetPayload<{}>): Types['listModel'] => {",
			"\t\treturn {",
			"\t\t\t",
			"\t\t};",
			"\t},",
			"\ttoDetails: (source: Prisma.${TM_FILENAME/(^[^.]+).*?([a-zA-Z0-9]*)$/${1:/pascalcase}/}GetPayload<{ include: { } }>): Types['details'] => {",
			"\t\treturn {",
			"\t\t\t",
			"\t\t};",
			"\t},",
			"\ttoCreatePayload: (source: Types['createPayload']): Prisma.${TM_FILENAME/(^[^.]+).*?([a-zA-Z0-9]*)$/${1:/pascalcase}/}CreateInput => {",
			"\t\treturn {",
			"\t\t\t",
			"\t\t};",
			"\t},",
			"\ttoUpdatePayload: (source: Types['updatePayload']): Prisma.${TM_FILENAME/(^[^.]+).*?([a-zA-Z0-9]*)$/${1:/pascalcase}/}UpdateInput => {",
			"\t\treturn {",
			"\t\t\t",
			"\t\t};",
			"\t}",
			"}",
			"",
			"@injectable()",
			"export class ${TM_FILENAME/(^[^.]+).*?([a-zA-Z0-9]*)$/${1:/pascalcase}/}PrismaStore implements ${TM_FILENAME/(^[^.]+).*?([a-zA-Z0-9]*)$/${1:/pascalcase}/}Store {",
			"\tlist: ${TM_FILENAME/(^[^.]+).*?([a-zA-Z0-9]*)$/${1:/pascalcase}/}Store['list'] = async (payload, { pageSize, zeroBasedIndex }) => {",
			"\t\tconst list = await prisma.${TM_FILENAME/(^[^.]+).*?([a-zA-Z0-9]*)$/${1:/camelcase}/}.findMany({",
			"\t\t\twhere: mappers.toFindListPayload(payload),",
			"\t\t\tskip: zeroBasedIndex * pageSize,",
			"\t\t\ttake: pageSize",
			"\t\t})",
			"\t\t",
			"\t\treturn list.map(mappers.toListModel)",
			"\t};",
			"",
			"\tdetails: ${TM_FILENAME/(^[^.]+).*?([a-zA-Z0-9]*)$/${1:/pascalcase}/}Store['details'] = async (payload) => {",
			"\t\tconst details = await prisma.${TM_FILENAME/(^[^.]+).*?([a-zA-Z0-9]*)$/${1:/camelcase}/}.findUnique({",
			"\t\t\twhere: mappers.toFindOnePayload(payload),",
			"\t\t\tinclude: {}",
			"\t\t})",
			"",
			"\t\tif (!details) {",
			"\t\t\treturn null",
			"\t\t}",
			"",
			"\t\treturn mappers.toDetails(details)",
			"\t};",
			"",
			"\tcreate: ${TM_FILENAME/(^[^.]+).*?([a-zA-Z0-9]*)$/${1:/pascalcase}/}Store['create'] = async (payload) => {",
			"\t\tconst { id } = await prisma.${TM_FILENAME/(^[^.]+).*?([a-zA-Z0-9]*)$/${1:/camelcase}/}.create({",
			"\t\t\tdata: mappers.toCreatePayload(payload),",
			"\t\t\tselect: { id: true }",
			"\t\t})",
			"",
			"\t\treturn { id }",
			"\t};",
			"",
			"\tupdateOne: ${TM_FILENAME/(^[^.]+).*?([a-zA-Z0-9]*)$/${1:/pascalcase}/}Store['updateOne'] = async (searchPayload, updatePayload) => {",
			"\t\ttry {",
			"\t\t\tawait prisma.${TM_FILENAME/(^[^.]+).*?([a-zA-Z0-9]*)$/${1:/camelcase}/}.update({",
			"\t\t\t\twhere: mappers.toFindOnePayload(searchPayload),",
			"\t\t\t\tdata: mappers.toUpdatePayload(updatePayload),",
			"\t\t\t})",
			"",
			"\t\t\treturn { success: true }",
			"\t\t}",
			"\t\tcatch {",
			"\t\t\treturn { success: false }",
			"\t\t}",
			"\t};",
			"",
			"\tdeleteOne: ${TM_FILENAME/(^[^.]+).*?([a-zA-Z0-9]*)$/${1:/pascalcase}/}Store['deleteOne'] = async (searchPayload) => {",
			"\t\ttry {",
			"\t\t\tawait prisma.${TM_FILENAME/(^[^.]+).*?([a-zA-Z0-9]*)$/${1:/camelcase}/}.delete({",
			"\t\t\t\twhere: mappers.toFindOnePayload(searchPayload),",
			"\t\t\t})",
			"",
			"\t\t\treturn { success: true }",
			"\t\t}",
			"\t\tcatch {",
			"\t\t\treturn { success: false }",
			"\t\t}",
			"\t};",
			"};"
		],
	},

	"RAM CRUD implementation": {
		"prefix": "_STORE-RAM",
		"body": [
			"import { RAMStore } from '@/backend/utils/store/store.utils.ram'",
			"import type { ${TM_FILENAME/(^[^.]+).*?([a-zA-Z0-9]*)$/${1:/pascalcase}/}Store } from './${TM_FILENAME_BASE/\\..*$//}.store'",
			"",
			"const ${TM_FILENAME/(^[^.]+).*?([a-zA-Z0-9]*)$/${1:/pascalcase}/}RAMStore = RAMStore<${TM_FILENAME/(^[^.]+).*?([a-zA-Z0-9]*)$/${1:/pascalcase}/}Store>()",
			"",
			"export { ${TM_FILENAME/(^[^.]+).*?([a-zA-Z0-9]*)$/${1:/pascalcase}/}RAMStore }"
		]
	}
}